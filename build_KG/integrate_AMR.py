"""
This script is used to integrate AMR data generated by AMRFinderPlus into a knolwedge graph.
"""

## Import standard libraries
import os
import sys
from tqdm import tqdm, trange
from glob import glob
import pandas as pd
import argparse
import logging
import pytaxonkit

## Import custom libraries
from utils import get_logger, read_tsv_file, Node, Edge, KnowledgeGraph, change_prefix, extract_disease_synonyms



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Integrate AMR data generated by AMRFinderPlus into a knolwedge graph')
    parser.add_argument('--existing_KG_nodes', type=str, help='path of the existing knowledge graph nodes')
    parser.add_argument('--existing_KG_edges', type=str, help='path of the existing knowledge graph edges')
    parser.add_argument('--amr_result', type=str, help='path of the AMR result file')
    parser.add_argument('--amr_metadata', type=str, help='path of the AMR metadata file')
    parser.add_argument('--coverage_threshold', type=float, default=80, help='coverage threshold for AMR gene selection')
    parser.add_argument('--identity_threshold', type=float, default=90, help='identity threshold for AMR gene selection')
    parser.add_argument('--output_dir', type=str, help='path of the output directory')
    args = parser.parse_args()

    # Create a logger object
    logger = get_logger()
    logger.setLevel(logging.DEBUG)

    # Create a knowledge graph object
    logger.info("Creating a knowledge graph object...")
    kg = KnowledgeGraph(logger)
    # Load existing knowledge graph nodes and edges
    logger.info("Loading existing knowledge graph nodes and edges...")
    node_filename = args.existing_KG_nodes.split('/')[-1]
    edge_filename = args.existing_KG_edges.split('/')[-1]
    kg.load_graph(load_dir=args.output_dir, node_filename=node_filename, edge_filename=edge_filename)

    # Load AMR result
    logger.info("Loading AMR result...")
    if not os.path.exists(args.amr_result):
        logger.error(f'Could not find AMR result file at {args.amr_result}')
        sys.exit(1)
    else:
        temp_file = read_tsv_file(args.amr_result)
        amr_result = pd.DataFrame(temp_file[1:], columns=temp_file[0])
    # remove rows with no aligned sequence
    amr_result = amr_result.loc[amr_result['Accession of closest sequence'] != '',:].reset_index(drop=True)
    # filter rows with coverage and identity
    amr_result = amr_result.loc[(amr_result['% Coverage of reference sequence'].astype(float) >= args.coverage_threshold) & (amr_result['% Identity to reference sequence'].astype(float) >= args.identity_threshold),:].reset_index(drop=True)
    # get ncbi id to name mapping
    result = pytaxonkit.lineage(list(set(amr_result.query('source == "NCBI"')['genome_id'])))
    ncbi_id_to_name = {str(taxid):name for taxid, name in result[['TaxID','Name']].to_numpy()}

    # Load AMR metadata
    temp_file = read_tsv_file(args.amr_metadata)
    amrfinderplus_metadata = pd.DataFrame(temp_file[1:], columns=temp_file[0])
    amrfinderplus_metadata = amrfinderplus_metadata[['gene_family','product_name','subtype','subclass','refseq_protein_accession','genbank_protein_accession']]
    amrfinderplus_metadata = amrfinderplus_metadata.loc[(amrfinderplus_metadata['refseq_protein_accession'] != '') | (amrfinderplus_metadata['genbank_protein_accession'] != ''),:].reset_index(drop=True)
    amrfinderplus_metadata = amrfinderplus_metadata.drop_duplicates().reset_index(drop=True)
    # merge duplicated info
    amr_dict = {}
    for row in tqdm(amrfinderplus_metadata.to_numpy(), desc='Merging duplicated info'):
        temp_gene_family, temp_product_name, temp_type, temp_class, temp_refseq_accession, temp_genbank_accession = row
        if not temp_refseq_accession:
            pass
        else:
            if temp_refseq_accession not in amr_dict:
                amr_dict[temp_refseq_accession] = {'gene_family': set(), 'product_name': set(), 'type': set(), 'class': set(), 'accession': set()}
            if temp_gene_family and not isinstance(temp_gene_family, float):
                amr_dict[temp_refseq_accession]['gene_family'].update([temp_gene_family])
            if temp_product_name and not isinstance(temp_product_name, float):
                amr_dict[temp_refseq_accession]['product_name'].update([temp_product_name])
            if temp_type and not isinstance(temp_type, float):
                amr_dict[temp_refseq_accession]['type'].update([temp_type])
            if temp_class and not isinstance(temp_class, float):
                amr_dict[temp_refseq_accession]['class'].update([temp_class])
            if temp_genbank_accession:
                amr_dict[temp_refseq_accession]['accession'].update([temp_refseq_accession, temp_genbank_accession])
            else:
                amr_dict[temp_refseq_accession]['accession'].update([temp_refseq_accession])

        if not temp_genbank_accession:
            pass
        else:
            if temp_genbank_accession not in amr_dict:
                amr_dict[temp_genbank_accession] = {'gene_family': set(), 'product_name': set(), 'type': set(), 'class': set(), 'accession': set()}
            if temp_gene_family and not isinstance(temp_gene_family, float):
                amr_dict[temp_genbank_accession]['gene_family'].update([temp_gene_family])
            if temp_product_name and not isinstance(temp_product_name, float):
                amr_dict[temp_genbank_accession]['product_name'].update([temp_product_name])
            if temp_type and not isinstance(temp_type, float):
                amr_dict[temp_genbank_accession]['type'].update([temp_type])
            if temp_class and not isinstance(temp_class, float):
                amr_dict[temp_genbank_accession]['class'].update([temp_class])
            if temp_refseq_accession:
                amr_dict[temp_genbank_accession]['accession'].update([temp_refseq_accession, temp_genbank_accession])
            else:
                amr_dict[temp_genbank_accession]['accession'].update([temp_genbank_accession])

    # Add AMR genes to KG
    columns_list = amr_result.columns.to_list()
    for row in tqdm(amr_result.to_numpy(), desc='Adding AMR genes to KG'):
        AMR_seq_id = row[columns_list.index('Accession of closest sequence')]
        genome_id = row[columns_list.index('genome_id')]
        source = row[columns_list.index('source')]
        
        ## process genome id node
        if source == 'GTDB':
            genome_synonyms = [f"GTDB:{genome_id}"]
        elif source == 'NCBI':
            genome_synonyms = [f"NCBI:{genome_id}", f"KEGG:gn_{genome_id}", f"NCBI:{ncbi_id_to_name[genome_id]}"]
        elif source == 'PATRIC':
            genome_synonyms = [f"BVBRC:gn_{genome_id}"]
        elif source == 'KEGG':
            genome_synonyms = [f"KEGG:gn_{genome_id}"]
        else:
            logger.debug(f'Unknown source {source}')
            continue
        
        # find if the genome node exit
        pass_flag = False
        for genome_synonym in genome_synonyms:
            genome_node_id = kg.find_node_by_synonym(f"{genome_synonym}")
            if not genome_node_id:
                logger.debug(f'Cannot find node for {genome_synonym}')
                continue
            else:
                pass_flag = True
                break
        if not pass_flag:
            if source == 'PATRIC':
                logger.debug(f'Skip {genome_id} because it may not be included in KG due to the lack of disease relationship')
                continue
            if source == 'GTDB':
                logger.debug(f'Skip {genome_id} because it does not exist in GTDB anymore. Please double check the genome id.')
                continue
            exit(1)
        
        ## process AMR gene node
        if AMR_seq_id in amr_dict:
            temp_gene_family = list(amr_dict[AMR_seq_id]['gene_family'])
            temp_all_names = list(amr_dict[AMR_seq_id]['product_name'])
            temp_type = list(amr_dict[AMR_seq_id]['type'])
            temp_class = list(amr_dict[AMR_seq_id]['class'])
            temp_accession = list(amr_dict[AMR_seq_id]['accession'])
            temp_link = [f"https://www.ncbi.nlm.nih.gov/protein/{x}" for x in temp_accession]
            
            
            # 1. if it is an existing node in the knowledge graph
            amr_node_id = kg.find_node_by_synonym(f"NCBI:pt_{AMR_seq_id}")
            if amr_node_id:
                existing_node = kg.get_node_by_id(amr_node_id)
                existing_node.synonyms = list(set(existing_node.synonyms + [f"NCBI:pt_{AMR_seq_id}"] + [f"NCBI:pt_{x}" for x in temp_accession]))
                existing_description_dict = dict(existing_node.description)
                existing_description_dict['gene_family'] = '#####'.join(list(set(existing_description_dict['gene_family'].split('#####') + temp_gene_family)))
                existing_description_dict['type'] = '#####'.join(list(set(existing_description_dict['type'].split('#####') + temp_type)))
                existing_description_dict['class'] = '#####'.join(list(set(existing_description_dict['class'].split('#####') + temp_class)))
                existing_node.description = list(existing_description_dict.items())
                existing_node.link = list(set(existing_node.link + temp_link))
                existing_node.all_names = list(set(existing_node.all_names + temp_all_names))
                existing_node.knowledge_source = list(set(existing_node.knowledge_source + ['NCBI']))
                existing_node.is_pathogen = False
            else:
                # 2. if it is not an existing node in the knowledge graph
                temp_node = Node(node_type="AMR", all_names=temp_all_names, description=[('gene_family', '#####'.join(temp_gene_family)), ('type', '#####'.join(temp_type)), ('class', '#####'.join(temp_class))], knowledge_source=['AMRFinderPlus'], synonyms=[f"NCBI:pt_{AMR_seq_id}"] + [f"NCBI:pt_{x}" for x in temp_accession], link=temp_link, is_pathogen=False)
                kg.add_node(temp_node)
        else:
            logger.error(f'Cannot find metadata for {AMR_seq_id}')
            exit(1)

    # Add edge between genome and AMR gene to KG
    for row in tqdm(amr_result.to_numpy(), desc='Adding edge between genome and AMR gene to KG'):
        temp_contig_id = row[columns_list.index('Contig id')]
        temp_start = row[columns_list.index('Start')]
        temp_stop = row[columns_list.index('Stop')]
        temp_strand = row[columns_list.index('Strand')]
        temp_method = row[columns_list.index('Method')]
        temp_target_length = row[columns_list.index('Target length')]
        temp_reference_length = row[columns_list.index('Reference sequence length')]
        temp_coverage = row[columns_list.index('% Coverage of reference sequence')]
        temp_identity = row[columns_list.index('% Identity to reference sequence')]
        temp_alignment_length = row[columns_list.index('Alignment length')]
        
        temp_AMR_seq_id = row[columns_list.index('Accession of closest sequence')]
        temp_genome_id = row[columns_list.index('genome_id')]
        temp_source = row[columns_list.index('source')]
        
        temp_description_dict = {}
        temp_description_dict[temp_contig_id] = f"Contig id: {temp_contig_id}; Start: {temp_start}; Stop: {temp_stop}; Strand: {temp_strand}; Method: {temp_method}; Target length: {temp_target_length}; Reference sequence length: {temp_reference_length}; Coverage: {temp_coverage}; Identity: {temp_identity}; Alignment length: {temp_alignment_length}" 

        if temp_source == 'GTDB':
            genome_node_id = kg.find_node_by_synonym(f"GTDB:{temp_genome_id}")
            if not genome_node_id:
                logger.debug(f'Skip {temp_genome_id} because it does not exist in GTDB anymore. Please double check the genome id.')
                continue
        elif temp_source == 'NCBI':
            for temp_genome_synonym in [f"NCBI:{temp_genome_id}", f"KEGG:gn_{temp_genome_id}", f"NCBI:{ncbi_id_to_name[temp_genome_id]}"]:
                genome_node_id = kg.find_node_by_synonym(f"{temp_genome_synonym}")
                if genome_node_id:
                    break
        elif temp_source == 'PATRIC':
            genome_node_id = kg.find_node_by_synonym(f"BVBRC:gn_{temp_genome_id}")
            if not genome_node_id:
                logger.debug(f'Skip {temp_genome_id} because it may not be included in KG due to the lack of disease relationship')
                continue
        else:
            genome_node_id = kg.find_node_by_synonym(f"KEGG:gn_{temp_genome_id}")
            
        amr_node_id = kg.find_node_by_synonym(f"NCBI:pt_{temp_AMR_seq_id}")
    
        kg.add_edge(Edge(source_node=amr_node_id, target_node=genome_node_id, predicate='biolink:associated_with', description=list(temp_description_dict.items()), knowledge_source=["AMRFinderPlus"]))
        kg.add_edge(Edge(source_node=genome_node_id, target_node=amr_node_id, predicate='biolink:associated_with', description=list(temp_description_dict.items()), knowledge_source=["AMRFinderPlus"]))

    # Save the knowledge graph
    logger.info("Saving the knowledge graph...")
    kg.save_graph(save_dir = args.output_dir, node_filename = 'KG_nodes_v6.tsv', edge_filename = 'KG_edges_v6.tsv')
    logger.info("KG node is saved to {}".format(os.path.join(args.output_dir, 'KG_nodes_v6.tsv')))
    logger.info("KG edge is saved to {}".format(os.path.join(args.output_dir, 'KG_edges_v6.tsv')))
    
    logger.info(f'Done!')

